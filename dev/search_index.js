var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = HGF","category":"page"},{"location":"#HGF","page":"Home","title":"HGF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HGF.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [HGF]","category":"page"},{"location":"#HGF.calculate_auxiliary_prediction_precision-Tuple{HGF.AbstractInputNode}","page":"Home","title":"HGF.calculate_auxiliary_prediction_precision","text":"calculate_auxiliary_prediction_precision(self::AbstractInputNode)\n\nAn input nodes auxiliary precision is always 1.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_auxiliary_prediction_precision-Tuple{HGF.AbstractNode}","page":"Home","title":"HGF.calculate_auxiliary_prediction_precision","text":"calculate_auxiliary_prediction_precision(self::AbstractNode)\n\nCalculates a node's auxiliary prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_mean-Tuple{HGF.AbstractNode, Vector{HGF.AbstractNode}, Vector{HGF.AbstractNode}}","page":"Home","title":"HGF.calculate_posterior_mean","text":"calculate_posterior_mean(self::AbstractNode, value_children, volatility_children)\n\nCalculates a node's posterior mean.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_mean-Tuple{HGF.BinaryStateNode, Vector{HGF.AbstractNode}, Vector{HGF.AbstractNode}}","page":"Home","title":"HGF.calculate_posterior_mean","text":"calculate_posterior_mean(self::BinaryStateNode, value_children, volatility_children)\n\nCalculates a node's posterior mean.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_mean_vape-Tuple{HGF.AbstractNode, HGF.AbstractNode}","page":"Home","title":"HGF.calculate_posterior_mean_vape","text":"calculate_posterior_mean_vape(\n    self::AbstractNode,\n    child::AbstractNode)\n\nCalculates the posterior mean update term for a single continuous value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_mean_vape-Tuple{HGF.AbstractNode, HGF.BinaryStateNode}","page":"Home","title":"HGF.calculate_posterior_mean_vape","text":"calculate_posterior_mean_vape(\n    self::AbstractNode,\n    child::BinaryStateNode)\n\nCalculates the posterior mean update term for a single binary value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_mean_vope-Tuple{HGF.AbstractNode, HGF.AbstractNode}","page":"Home","title":"HGF.calculate_posterior_mean_vope","text":"calculate_posterior_mean_vope(\n    self::AbstractNode,\n    child::Any)\n\nCalculates the posterior mean update term for a single continuos volatility child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_precision-Tuple{HGF.AbstractNode, Vector{HGF.AbstractNode}, Vector{HGF.AbstractNode}}","page":"Home","title":"HGF.calculate_posterior_precision","text":"calculate_posterior_precision(\n    self::AbstractNode,\n    value_children,\n    volatility_children)\n\nCalculates a node's posterior precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_precision-Tuple{HGF.BinaryStateNode, Vector{HGF.AbstractNode}, Vector{HGF.AbstractNode}}","page":"Home","title":"HGF.calculate_posterior_precision","text":"calculate_posterior_precision(\n    self::BinaryStateNode,\n    value_children,\n    volatility_children)\n\nCalculates a binary node's posterior precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_precision_vape-Tuple{HGF.AbstractNode, HGF.AbstractNode}","page":"Home","title":"HGF.calculate_posterior_precision_vape","text":"calculate_posterior_precision_vape(\n    self::AbstractNode,\n    child::AbstractNode)\n\nCalculates the posterior precision update term for a single continuous value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_precision_vape-Tuple{HGF.AbstractNode, HGF.BinaryStateNode}","page":"Home","title":"HGF.calculate_posterior_precision_vape","text":"calculate_posterior_precision_vape(\n    self::AbstractNode,\n    child::BinaryStateNode)\n\nCalculates the posterior precision update term for a single binary value child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_posterior_precision_vope-Tuple{HGF.AbstractNode, HGF.AbstractNode}","page":"Home","title":"HGF.calculate_posterior_precision_vope","text":"calculate_posterior_precision_vope(\n    posterior_precision::Real,\n    self::AbstractNode,\n    volatility_children::Any)\n\nCalculates the posterior precision update term for a single continuous volatility child to a state node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_mean-Tuple{HGF.AbstractNode, Vector{HGF.AbstractStateNode}}","page":"Home","title":"HGF.calculate_prediction_mean","text":"calculate_prediction_mean(self::AbstractNode, value_parent::Any)\n\nCalculates a node's prediction mean.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_mean-Tuple{HGF.BinaryStateNode, Vector{HGF.AbstractStateNode}}","page":"Home","title":"HGF.calculate_prediction_mean","text":"calculate_prediction_mean(self::AbstractNode, value_parent::Any)\n\nCalculates a binary state node's prediction mean.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_precision-Tuple{HGF.AbstractInputNode}","page":"Home","title":"HGF.calculate_prediction_precision","text":"calculate_prediction_precision(self::InputNode)\n\nCalculates an input node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_precision-Tuple{HGF.AbstractNode}","page":"Home","title":"HGF.calculate_prediction_precision","text":"calculate_prediction_precision(self::StateNode)\n\nCalculates a node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_precision-Tuple{HGF.BinaryStateNode}","page":"Home","title":"HGF.calculate_prediction_precision","text":"calculate_prediction_precision(self::BinaryStateNode)\n\nCalculates a binary state node's prediction precision.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_prediction_volatility-Tuple{HGF.AbstractNode, Vector{HGF.AbstractStateNode}}","page":"Home","title":"HGF.calculate_prediction_volatility","text":"calculate_prediction_volatility(self::AbstractNode,  volatility_parents::Any)\n\nCalculates a node's prediction volatility.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_value_prediction_error-Tuple{HGF.AbstractNode}","page":"Home","title":"HGF.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::AbstractNode)\n\nCalculate's a state node's value prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_value_prediction_error-Tuple{HGF.BinaryInputNode}","page":"Home","title":"HGF.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::BinaryInputNode)\n\nCalculates the prediciton error of a binary input node with finite precision\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_value_prediction_error-Tuple{HGF.InputNode, Vector{HGF.AbstractStateNode}}","page":"Home","title":"HGF.calculate_value_prediction_error","text":"calculate_value_prediction_error(self::InputNode, value_parents::Any)\n\nCalculate's an input node's value prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_volatility_prediction_error-Tuple{HGF.AbstractNode}","page":"Home","title":"HGF.calculate_volatility_prediction_error","text":"calculate_volatility_prediction_error(self::AbstractNode)\n\nCalculates a state node's volatility prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.calculate_volatility_prediction_error-Tuple{HGF.InputNode, Vector{HGF.AbstractStateNode}}","page":"Home","title":"HGF.calculate_volatility_prediction_error","text":"calculate_volatility_prediction_error(self::InputNode, value_parents::Any)\n\nCalculates an input node's volatility prediction error.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.check_hgf-Tuple{HGF.BinaryInputNode}","page":"Home","title":"HGF.check_hgf","text":"check_hgf(node::BinaryInputNode)\n\nFunction for checking the validity of a single binary input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.check_hgf-Tuple{HGF.BinaryStateNode}","page":"Home","title":"HGF.check_hgf","text":"check_hgf(node::BinaryStateNode)\n\nFunction for checking the validity of a single binary state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.check_hgf-Tuple{HGF.HGFStruct}","page":"Home","title":"HGF.check_hgf","text":"Function for checking if the specified HGF structure is valid\n\n\n\n\n\n","category":"method"},{"location":"#HGF.check_hgf-Tuple{HGF.InputNode}","page":"Home","title":"HGF.check_hgf","text":"check_hgf(node::InputNode)\n\nFunction for checking the validity of a single continuous input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.check_hgf-Tuple{HGF.StateNode}","page":"Home","title":"HGF.check_hgf","text":"check_hgf(node::StateNode)\n\nFunction for checking the validity of a single continous state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.create_binary_softmax_response-Tuple{}","page":"Home","title":"HGF.create_binary_softmax_response","text":"create_binary_softmax_response(; state::String = \"x1__prediction_mean\")\n\nFunction for creating a customized binary softmax action model. Takes a state as argument. Outputs a function which inputs the state into a softmax, to get the action probability for a Bernoulli distribution.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.create_gaussian_response-Tuple{}","page":"Home","title":"HGF.create_gaussian_response","text":"create_gaussian_response(state::Vector{String})\n\nFunction for creating a customized gaussian response action model. Takes a node name and a string of states as arguments. Outputs a function which reports a linear combination of the chosen states from the chosen node with some noise.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.create_node-NTuple{4, Any}","page":"Home","title":"HGF.create_node","text":"create_node(input_or_state_node, defaults, node_defaults, node_info)\n\nFunction for creating a node, given specifications\n\n\n\n\n\n","category":"method"},{"location":"#HGF.create_unit_square_sigmoid_response-Tuple{}","page":"Home","title":"HGF.create_unit_square_sigmoid_response","text":"create_unit_square_sigmoid_response(; state::String = \"x1__prediction_mean\")\n\nFunction for creating a customized binary unit square sigmoid action model. Takes a state as argument. Outputs a function which inputs the state into a unit square sigmoid, to get the action probability for a Bernoulli distribution.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.enter_node_inputs!-Tuple{HGF.HGFStruct, Dict}","page":"Home","title":"HGF.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGFStruct, inputs::Dict)\n\nFunction for entering multiple inputs, structured as a dictionary, to multiple input nodes.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.enter_node_inputs!-Tuple{HGF.HGFStruct, Union{Real, Tuple{Real}}}","page":"Home","title":"HGF.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGFStruct, input::Number)\n\nFunction for entering a single input to a single input node. Can either take a single number, or a tuple which also includes the precision of the input.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.enter_node_inputs!-Tuple{HGF.HGFStruct, Vector}","page":"Home","title":"HGF.enter_node_inputs!","text":"enter_node_inputs!(hgf::HGFStruct, inputs::Vector)\n\nFunction for entering multiple inputs, structured as a vector, to multiple input nodes.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.AgentStruct, Array}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(agent::AgentStruct, inputs::Array)\n\nFunction for inputting multiple observations to an agent. Input is structured as an array, with one column per input node and one row per timestep.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.AgentStruct, Dict{String, Vector}}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(agent::AgentStruct, inputs::Dict{String,Vector})\n\nFunction for inputting multiple observations to an agent. Input is structured as a dictionary with a vector for each input node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.AgentStruct, Number}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(agent::AgentStruct, inputs::Number)\n\nFunction for giving multiple inputs to an AgentStruct. Here a single number is passed as an input.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.HGFStruct, Array}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(hgf::HGFStruct, inputs::Array)\n\nFunction for inputting multiple observations to an hgf. Input is structured as an array, with one column per input node and one row per timestep.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.HGFStruct, Dict{String, Vector}}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(hgf::HGFStruct, inputs::Dict{String,Vector})\n\nFunction for inputting multiple observations to an hgf. Input is structured as a dictionary with a vector for each input node.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.give_inputs!-Tuple{HGF.HGFStruct, Number}","page":"Home","title":"HGF.give_inputs!","text":"give_inputs!(hgf::HGFStruct, inputs::Number)\n\nFunction for inputting multiple observations to an hgf. Input is a single value.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.init_hgf-Tuple{NamedTuple, Vector, Vector, Vector}","page":"Home","title":"HGF.init_hgf","text":"function init_hgf(\n    default_params,\n    input_nodes,\n    state_nodes,\n    edges,\n    update_order = false,\n)\n\nFunction for initializing the structure of an HGF model.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.premade_JGET","page":"Home","title":"HGF.premade_JGET","text":"premade_JGET(params_list, starting_state_list)\n\nThe JGET model. It has a single continuous input node u, with a value parent x1, and a volatility parent x3. x1 has volatility parent x2, and x3 has a volatility parent x4.\n\n\n\n\n\n","category":"function"},{"location":"#HGF.premade_agent","page":"Home","title":"HGF.premade_agent","text":"function premade_agent(\n    model_name::String,\n    perception_model = (;),\n    params = Dict(),\n    states = Dict(),\n    specifications = (;),\n)\n\nFunction for initializing the structure of an agent model.\n\n\n\n\n\n","category":"function"},{"location":"#HGF.premade_binary_2level-Tuple{}","page":"Home","title":"HGF.premade_binary_2level","text":"premade_binary_2level(params_list, starting_state_list)\n\nThe standard binary 2 level HGF model\n\n\n\n\n\n","category":"method"},{"location":"#HGF.premade_binary_3level-Tuple{}","page":"Home","title":"HGF.premade_binary_3level","text":"premade_binary_3level(params_list, starting_state_list)\n\nThe standard binary 3 level HGF model\n\n\n\n\n\n","category":"method"},{"location":"#HGF.premade_continuous_2level-Tuple{}","page":"Home","title":"HGF.premade_continuous_2level","text":"premade_continuous_2level(params_list, starting_state_list)\n\nThe standard 2 level HGF. It has a continous input node U, with a single value parent x1, which in turn has a single volatility parent x2.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.premade_hgf","page":"Home","title":"HGF.premade_hgf","text":"function premade_hgf(\n    model_name,\n    params,\n    starting_state,\n)\n\nFunction for initializing the structure of an HGF model.\n\n\n\n\n\n","category":"function"},{"location":"#HGF.update_hgf!-Tuple{HGF.HGFStruct, Any}","page":"Home","title":"HGF.update_hgf!","text":"update_hgf!(hgf::HGFStruct, inputs) \n\nFunction for updating all nodes in an HGF hierarchy.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_input!-Tuple{HGF.AbstractInputNode, Real}","page":"Home","title":"HGF.update_node_input!","text":"update_node_input!(self::InputNode, input::Real)\n\nFunction for updating the input for a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_posterior!-Tuple{HGF.AbstractStateNode}","page":"Home","title":"HGF.update_node_posterior!","text":"update_node_posterior!(self::StateNode)\n\nFunction for updating the posterior of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_prediction!-Tuple{HGF.AbstractInputNode}","page":"Home","title":"HGF.update_node_prediction!","text":"update_node_prediction!(self::InputNode)\n\nFunction for updating the posterior of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_prediction!-Tuple{HGF.AbstractStateNode}","page":"Home","title":"HGF.update_node_prediction!","text":"update_node_prediction!(self::StateNode)\n\nFunction for updating the prediction for a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_prediction!-Tuple{HGF.BinaryInputNode}","page":"Home","title":"HGF.update_node_prediction!","text":"update_node_prediction!(self::BinaryInputNode)\n\nThe prediction precision is constant for binary input nodes, so nothing is done here.\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_prediction!-Tuple{HGF.BinaryStateNode}","page":"Home","title":"HGF.update_node_prediction!","text":"update_node_prediction!(self::BinaryStateNode)\n\nFunction for updating the prediction for a single Binary state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_value_prediction_error!-Tuple{HGF.AbstractInputNode}","page":"Home","title":"HGF.update_node_value_prediction_error!","text":"update_node_value_prediction_error!(self::InputNode)\n\nFunction for updating the value prediction error of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_value_prediction_error!-Tuple{HGF.AbstractStateNode}","page":"Home","title":"HGF.update_node_value_prediction_error!","text":"Function for updating the value prediction error of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_value_prediction_error!-Tuple{HGF.BinaryInputNode}","page":"Home","title":"HGF.update_node_value_prediction_error!","text":"update_node_value_prediction_error!(self::BinaryInputNode)\n\nFunction for updating the value prediction error of a single input node. \n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_volatility_prediction_error!-Tuple{HGF.AbstractInputNode}","page":"Home","title":"HGF.update_node_volatility_prediction_error!","text":"update_node_volatility_prediction_error!(self::InputNode)\n\nFunction for updating the volatility prediction error of a single input node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_volatility_prediction_error!-Tuple{HGF.AbstractStateNode}","page":"Home","title":"HGF.update_node_volatility_prediction_error!","text":"Function for updating the volatility prediction error of a single state node\n\n\n\n\n\n","category":"method"},{"location":"#HGF.update_node_volatility_prediction_error!-Tuple{HGF.BinaryInputNode}","page":"Home","title":"HGF.update_node_volatility_prediction_error!","text":"update_node_volatility_prediction_error!(self::BinaryInputNode)\n\nThere is no volatility prediction error for binary input nodes.\n\n\n\n\n\n","category":"method"}]
}
